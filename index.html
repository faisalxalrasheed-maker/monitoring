<script>
// =============== NEW ENHANCEMENTS ===============

// 1. AI-Powered Anomaly Detection
function detectAnomalies() {
  urls.forEach(url => {
    const recentHistory = (url.history || []).slice(-50);
    const responseTimes = recentHistory.map(h => h.rt).filter(rt => typeof rt === 'number');
    
    if (responseTimes.length >= 10) {
      const avg = average(responseTimes);
      const stdDev = Math.sqrt(responseTimes.reduce((sum, rt) => sum + Math.pow(rt - avg, 2), 0) / responseTimes.length);
      const latestRT = responseTimes[responseTimes.length - 1];
      
      // Detect significant deviations (3 sigma rule)
      if (Math.abs(latestRT - avg) > 3 * stdDev) {
        addAlert(url.url, 'Performance Anomaly Detected', 
          `Response time anomaly: ${Math.round(latestRT)}ms (normally ${Math.round(avg)}ms Â± ${Math.round(stdDev)}ms)`, 
          'warning');
      }
    }
  });
}

// 2. Multi-Region Monitoring Simulation
async function checkFromMultipleRegions(url) {
  const regions = ['us-east', 'us-west', 'eu-central', 'asia-southeast'];
  const regionResults = [];
  
  for (const region of regions) {
    try {
      const start = performance.now();
      // Simulate region-based latency
      const latency = Math.random() * 100 + (region === 'asia-southeast' ? 200 : 0);
      await new Promise(resolve => setTimeout(resolve, latency));
      
      const { rt } = await pingFavicon(url, settings.timeoutMs - latency);
      regionResults.push({
        region,
        responseTime: rt + latency,
        status: 'online'
      });
    } catch (error) {
      regionResults.push({
        region,
        responseTime: null,
        status: 'offline',
        error: error.message
      });
    }
  }
  
  return regionResults;
}

// 3. Advanced Performance Metrics
function calculateAdvancedMetrics() {
  return urls.map(url => {
    const history = url.history || [];
    const responseTimes = history.map(h => h.rt).filter(rt => typeof rt === 'number');
    
    if (responseTimes.length === 0) return null;
    
    const sorted = [...responseTimes].sort((a, b) => a - b);
    const p95 = sorted[Math.floor(sorted.length * 0.95)];
    const p99 = sorted[Math.floor(sorted.length * 0.99)];
    
    return {
      url: url.url,
      min: Math.min(...responseTimes),
      max: Math.max(...responseTimes),
      median: sorted[Math.floor(sorted.length / 2)],
      p95,
      p99,
      errorRate: (history.filter(h => h.status === 'offline').length / history.length) * 100
    };
  }).filter(Boolean);
}

// 4. Predictive Uptime Forecasting
function predictUptime(url) {
  const history = url.history || [];
  const recentUptime = calculateUptime(history, 24);
  const weeklyUptime = calculateUptime(history, 24 * 7);
  
  // Simple weighted average prediction
  const predictedUptime = (recentUptime * 0.7 + weeklyUptime * 0.3);
  
  return {
    current: recentUptime,
    predicted: Math.round(predictedUptime),
    trend: recentUptime > weeklyUptime ? 'improving' : recentUptime < weeklyUptime ? 'declining' : 'stable'
  };
}

// 5. Advanced SSL Certificate Analysis
async function advancedSSLCheck(url) {
  const basicInfo = await checkSSLCertificate(url);
  
  // Enhanced SSL analysis
  const enhancedInfo = {
    ...basicInfo,
    grade: calculateSSLGrade(basicInfo),
    recommendations: generateSSLRecommendations(basicInfo),
    vulnerabilities: checkSSLVulnerabilities(basicInfo)
  };
  
  return enhancedInfo;
}

function calculateSSLGrade(sslInfo) {
  if (!sslInfo.valid) return 'F';
  if (sslInfo.daysRemaining > 90) return 'A+';
  if (sslInfo.daysRemaining > 60) return 'A';
  if (sslInfo.daysRemaining > 30) return 'B';
  if (sslInfo.daysRemaining > 14) return 'C';
  if (sslInfo.daysRemaining > 7) return 'D';
  return 'F';
}

// 6. Dependency Mapping
const dependencyMap = new Map();

function buildDependencyMap() {
  dependencyMap.clear();
  
  urls.forEach(url => {
    const domain = new URL(url.url).hostname;
    const dependencies = findDependencies(domain);
    dependencyMap.set(url.url, dependencies);
  });
}

function findDependencies(domain) {
  // Simulate finding dependencies (CDNs, APIs, etc.)
  const commonDependencies = {
    'google.com': ['fonts.googleapis.com', 'ajax.googleapis.com', 'www.gstatic.com'],
    'example.com': ['api.example.com', 'cdn.example.com', 'assets.example.com']
  };
  
  return commonDependencies[domain] || [];
}

// 7. Automated Root Cause Analysis
function performRootCauseAnalysis(downUrls) {
  const affectedDomains = downUrls.map(url => new URL(url).hostname);
  const potentialCauses = [];
  
  // Check for shared dependencies
  dependencyMap.forEach((dependencies, url) => {
    const urlDomain = new URL(url).hostname;
    if (affectedDomains.includes(urlDomain)) {
      dependencies.forEach(dep => {
        if (!urls.some(u => u.url.includes(dep))) {
          potentialCauses.push(`Missing dependency: ${dep}`);
        }
      });
    }
  });
  
  // Check for pattern in downtime
  if (downUrls.length > urls.length * 0.5) {
    potentialCauses.push('Potential network outage or DNS issues');
  }
  
  return [...new Set(potentialCauses)];
}

// 8. Business Impact Assessment
function calculateBusinessImpact(url) {
  // Define URL categories and their impact weights
  const impactWeights = {
    'critical': 10,    // Core application, payment processing
    'high': 7,         // Main services, APIs
    'medium': 4,       // Secondary services, documentation
    'low': 1           // Monitoring, status pages
  };
  
  let category = 'medium';
  if (url.includes('/api/') || url.includes('/payment')) category = 'critical';
  else if (url.includes('/admin') || url.includes('/dashboard')) category = 'high';
  else if (url.includes('/docs') || url.includes('/blog')) category = 'low';
  
  const uptime = calculateUptime(url.history || [], 24);
  const impactScore = (100 - uptime) * impactWeights[category];
  
  return {
    category,
    impactScore: Math.round(impactScore),
    financialImpact: calculateFinancialImpact(url, uptime)
  };
}

function calculateFinancialImpact(url, uptime) {
  // Simple simulation - in real scenario, this would use actual business metrics
  const downtimeMinutes = (100 - uptime) * 14.4; // 24h * 60min * 0.01
  const costPerMinute = url.includes('/api/') ? 10 : url.includes('/payment') ? 50 : 1;
  
  return Math.round(downtimeMinutes * costPerMinute);
}

// 9. Advanced Alert Correlation
function correlateAlerts() {
  const recentAlerts = alerts.filter(a => a.timestamp > now() - 3600000); // Last hour
  const alertGroups = {};
  
  recentAlerts.forEach(alert => {
    const key = `${alert.type}-${alert.title}`;
    if (!alertGroups[key]) alertGroups[key] = [];
    alertGroups[key].push(alert);
  });
  
  // Correlated alerts (same type/title within short period)
  Object.entries(alertGroups).forEach(([key, groupAlerts]) => {
    if (groupAlerts.length >= 3) {
      const correlatedAlert = {
        id: now() + Math.random(),
        timestamp: now(),
        title: `Correlated Alert: ${groupAlerts[0].title}`,
        message: `${groupAlerts.length} occurrences in the last hour`,
        type: 'warning',
        correlated: true,
        originalAlerts: groupAlerts.map(a => a.id)
      };
      
      if (!alerts.some(a => a.correlated && a.originalAlerts?.includes(groupAlerts[0].id))) {
        alerts.unshift(correlatedAlert);
      }
    }
  });
}

// 10. Automated Recovery Verification
async function verifyRecovery(url) {
  let recoveryVerified = false;
  let attempts = 0;
  
  while (!recoveryVerified && attempts < 5) {
    attempts++;
    try {
      const { rt } = await pingFavicon(url, settings.timeoutMs);
      if (rt < settings.responseTimeCritical) {
        recoveryVerified = true;
        addAlert(url, 'Recovery Verified', 
          `Service recovered after ${attempts} verification attempts. Response time: ${Math.round(rt)}ms`, 
          'success');
      }
    } catch (error) {
      await new Promise(resolve => setTimeout(resolve, 30000)); // Wait 30 seconds
    }
  }
  
  if (!recoveryVerified) {
    addAlert(url, 'Recovery Failed', 
      'Service failed to recover after multiple verification attempts', 
      'error');
  }
}

// 11. Capacity Planning Insights
function generateCapacityInsights() {
  const insights = [];
  const peakHours = findPeakUsageHours();
  
  peakHours.forEach(hour => {
    const load = calculateHourlyLoad(hour.hour);
    if (load > 0.8) { // 80% capacity threshold
      insights.push({
        hour: hour.hour,
        load: Math.round(load * 100),
        recommendation: 'Consider scaling resources during this period'
      });
    }
  });
  
  return insights;
}

function findPeakUsageHours() {
  const hourlyRequests = Array(24).fill(0);
  
  urls.forEach(url => {
    url.history?.forEach(check => {
      if (check.status === 'online') {
        const hour = new Date(check.t).getHours();
        hourlyRequests[hour]++;
      }
    });
  });
  
  return hourlyRequests.map((count, hour) => ({ hour, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 3);
}

// 12. Security Vulnerability Scanning
async function scanSecurityVulnerabilities(url) {
  const vulnerabilities = [];
  
  // Check for common security headers
  try {
    const response = await fetch(url, { method: 'HEAD' });
    const headers = response.headers;
    
    if (!headers.get('X-Content-Type-Options')) {
      vulnerabilities.push('Missing X-Content-Type-Options header');
    }
    if (!headers.get('X-Frame-Options')) {
      vulnerabilities.push('Missing X-Frame-Options header');
    }
    if (!headers.get('Strict-Transport-Security')) {
      vulnerabilities.push('Missing HSTS header');
    }
  } catch (error) {
    // Can't check headers due to CORS
  }
  
  // Check for exposed sensitive files
  const sensitivePaths = ['/.env', '/.git/config', '/backup.zip', '/wp-config.php'];
  for (const path of sensitivePaths) {
    try {
      const testUrl = new URL(path, url).toString();
      await fetch(testUrl, { method: 'HEAD' });
      vulnerabilities.push(`Exposed sensitive file: ${path}`);
    } catch (error) {
      // File not exposed or not accessible
    }
  }
  
  return vulnerabilities;
}

// 13. Performance Budget Monitoring
function checkPerformanceBudgets() {
  const budgets = {
    'first-contentful-paint': 1000,
    'largest-contentful-paint': 2500,
    'cumulative-layout-shift': 0.1,
    'first-input-delay': 100
  };
  
  urls.forEach(url => {
    const lastRT = url.history?.slice(-1)[0]?.rt;
    if (lastRT && lastRT > budgets['first-contentful-paint']) {
      addAlert(url.url, 'Performance Budget Exceeded', 
        `Response time ${Math.round(lastRT)}ms exceeds budget of ${budgets['first-contentful-paint']}ms`, 
        'warning');
    }
  });
}

// 14. Automated Documentation Generation
function generateMonitoringDocumentation() {
  const doc = {
    generatedAt: new Date().toISOString(),
    summary: {
      totalEndpoints: urls.length,
      criticalEndpoints: urls.filter(u => calculateBusinessImpact(u).category === 'critical').length,
      averageUptime: calculateOverallUptime(30),
      healthScore: calculateHealthScore()
    },
    endpoints: urls.map(url => ({
      url: url.url,
      businessImpact: calculateBusinessImpact(url).category,
      sla: calculateUptime(url.history || [], 30),
      dependencies: dependencyMap.get(url.url) || [],
      lastIncident: alerts.filter(a => a.url === url.url).slice(-1)[0] || null
    })),
    alerts: {
      last24h: alerts.filter(a => a.timestamp > now() - 86400000).length,
      critical: alerts.filter(a => a.type === 'error').length
    }
  };
  
  return doc;
}

// 15. Real-time Collaboration Features
const collaboration = {
  users: new Map(),
  incidents: new Map(),
  
  addUser(name, role = 'viewer') {
    this.users.set(name, { name, role, lastActive: now() });
    this.broadcastUserUpdate();
  },
  
  startIncident(title, severity) {
    const incident = {
      id: now(),
      title,
      severity,
      startTime: now(),
      status: 'active',
      assignedTo: null,
      updates: []
    };
    
    this.incidents.set(incident.id, incident);
    this.broadcastIncidentUpdate(incident);
    return incident;
  },
  
  broadcastUserUpdate() {
    // In real implementation, this would use WebSockets
    console.log('Users updated:', Array.from(this.users.values()));
  },
  
  broadcastIncidentUpdate(incident) {
    // In real implementation, this would use WebSockets
    console.log('Incident updated:', incident);
  }
};

// 16. Advanced Data Retention Policies
function applyDataRetentionPolicy() {
  const retentionDays = settings.dataRetentionDays || 30;
  const cutoffTime = now() - (retentionDays * 24 * 60 * 60 * 1000);
  
  urls.forEach(url => {
    url.history = (url.history || []).filter(h => h.t >= cutoffTime);
  });
  
  alerts = alerts.filter(alert => alert.timestamp >= cutoffTime);
  
  console.log(`Applied data retention policy: ${retentionDays} days`);
}

// 17. Machine Learning-Based Forecasting
function forecastMetrics() {
  const forecasts = {};
  
  urls.forEach(url => {
    const responseTimes = (url.history || [])
      .map(h => h.rt)
      .filter(rt => typeof rt === 'number')
      .slice(-100); // Last 100 data points
    
    if (responseTimes.length >= 20) {
      // Simple linear regression for forecasting
      const forecast = simpleLinearForecast(responseTimes, 24); // Next 24 periods
      forecasts[url.url] = {
        current: responseTimes[responseTimes.length - 1],
        forecast: Math.round(forecast),
        trend: forecast > responseTimes[responseTimes.length - 1] ? 'increasing' : 'decreasing'
      };
    }
  });
  
  return forecasts;
}

function simpleLinearForecast(data, periods) {
  const n = data.length;
  const xMean = (n - 1) / 2;
  const yMean = average(data);
  
  let numerator = 0;
  let denominator = 0;
  
  data.forEach((y, x) => {
    numerator += (x - xMean) * (y - yMean);
    denominator += Math.pow(x - xMean, 2);
  });
  
  const slope = numerator / denominator;
  return yMean + slope * (n + periods - 1 - xMean);
}

// 18. Compliance Reporting (GDPR, HIPAA, etc.)
function generateComplianceReport(standard = 'GDPR') {
  const checks = {
    'GDPR': [
      'Data encryption in transit',
      'Privacy policy accessibility',
      'Cookie consent compliance',
      'Data breach notification'
    ],
    'HIPAA': [
      'PHI data protection',
      'Access controls',
      'Audit trails',
      'Data backup'
    ]
  };
  
  const report = {
    standard,
    generated: new Date().toISOString(),
    checks: checks[standard] || [],
    status: 'compliant', // Simplified
    findings: [],
    recommendations: [
      'Implement regular security audits',
      'Ensure all endpoints use HTTPS',
      'Maintain access logs for 6+ months'
    ]
  };
  
  return report;
}

// 19. Advanced Notification Routing
const notificationRoutes = {
  'critical': ['sms', 'email', 'slack'],
  'warning': ['email', 'slack'],
  'info': ['slack']
};

function routeNotification(alert, severity = 'warning') {
  const channels = notificationRoutes[severity] || notificationRoutes['warning'];
  
  channels.forEach(channel => {
    switch (channel) {
      case 'sms':
        sendSMSNotification(alert);
        break;
      case 'email':
        sendEmailNotification(alert);
        break;
      case 'slack':
        sendSlackNotification(alert);
        break;
    }
  });
}

function sendSMSNotification(alert) {
  // Integration with SMS gateway
  console.log('SMS Alert:', alert.title, alert.message);
}

function sendEmailNotification(alert) {
  // Integration with email service
  console.log('Email Alert:', alert.title, alert.message);
}

function sendSlackNotification(alert) {
  // Integration with Slack webhook
  console.log('Slack Alert:', alert.title, alert.message);
}

// 20. Automated Incident Response
async function automatedIncidentResponse(downUrl) {
  const incident = collaboration.startIncident(`Service Down: ${downUrl}`, 'critical');
  
  // Step 1: Verify the outage
  await new Promise(resolve => setTimeout(resolve, 60000)); // Wait 1 minute
  const verification = await pingFavicon(downUrl, settings.timeoutMs).catch(() => null);
  
  if (!verification) {
    // Step 2: Check dependencies
    const dependencies = dependencyMap.get(downUrl) || [];
    const dependencyStatus = await Promise.all(
      dependencies.map(dep => pingFavicon(`https://${dep}`, settings.timeoutMs).catch(() => null))
    );
    
    // Step 3: Notify team
    routeNotification({
      title: `INCIDENT: ${downUrl} is down`,
      message: `Dependencies checked: ${dependencies.join(', ')}`
    }, 'critical');
    
    // Step 4: Update incident
    incident.updates.push({
      timestamp: now(),
      action: 'automated_verification',
      details: 'Outage confirmed, dependencies checked'
    });
    
    collaboration.broadcastIncidentUpdate(incident);
  }
}

// 21. Resource Utilization Monitoring
function monitorResourceUtilization() {
  if (typeof performance !== 'undefined' && performance.memory) {
    const memory = performance.memory;
    return {
      usedJSHeapSize: Math.round(memory.usedJSHeapSize / 1048576), // MB
      totalJSHeapSize: Math.round(memory.totalJSHeapSize / 1048576),
      jsHeapSizeLimit: Math.round(memory.jsHeapSizeLimit / 1048576),
      utilization: Math.round((memory.usedJSHeapSize / memory.totalJSHeapSize) * 100)
    };
  }
  return null;
}

// 22. Advanced Filtering and Query Language
function advancedQuery(query) {
  // Simple query language implementation
  const tokens = query.toLowerCase().split(' ');
  
  return urls.filter(url => {
    return tokens.every(token => {
      if (token.startsWith('status:')) {
        const status = token.split(':')[1];
        const lastStatus = url.history?.slice(-1)[0]?.status;
        return lastStatus === status;
      }
      if (token.startsWith('tag:')) {
        const tag = token.split(':')[1];
        return url.tags?.includes(tag);
      }
      if (token.startsWith('rt>')) {
        const threshold = parseInt(token.split('>')[1]);
        const lastRT = url.history?.slice(-1)[0]?.rt;
        return lastRT > threshold;
      }
      
      return url.url.toLowerCase().includes(token);
    });
  });
}

// 23. Integration with External Monitoring Services
const externalIntegrations = {
  async checkWithUptimeRobot(url) {
    // Simulate integration with UptimeRobot API
    try {
      const response = await fetch(`https://api.uptimerobot.com/v2/getMonitors?api_key=YOUR_KEY&url=${encodeURIComponent(url)}`);
      const data = await response.json();
      return data.monitors?.[0] || null;
    } catch (error) {
      return null;
    }
  },
  
  async pushToDatadog(metrics) {
    // Simulate integration with Datadog
    console.log('Pushing metrics to Datadog:', metrics);
  },
  
  async createGithubIssue(alert) {
    // Simulate creating GitHub issue for critical alerts
    if (alert.type === 'error') {
      console.log('Creating GitHub issue for:', alert.title);
    }
  }
};

// 24. Custom Check Intervals per URL
function updateCustomIntervals() {
  urls.forEach(url => {
    if (url.customInterval) {
      const lastCheck = url.lastCheck || 0;
      const interval = url.customInterval * 1000;
      
      if (now() - lastCheck >= interval) {
        checkUrl(url);
      }
    }
  });
}

// 25. Advanced Visualization and Dashboard Customization
function createCustomDashboard() {
  return {
    widgets: [
      {
        type: 'uptime-gauge',
        title: 'Overall Uptime',
        data: calculateOverallUptime(30)
      },
      {
        type: 'response-time-chart',
        title: 'Response Times',
        data: calculateAdvancedMetrics()
      },
      {
        type: 'health-score',
        title: 'System Health',
        data: calculateHealthScore()
      }
    ],
    layout: 'grid', // 'grid', 'list', 'custom'
    refreshRate: 30000 // 30 seconds
  };
}

// =============== INTEGRATION WITH EXISTING CODE ===============

// Update the checkUrl function to include new features
async function enhancedCheckUrl(item, retryCount = 0) {
  try {
    const { rt } = await pingFavicon(item.url, settings.timeoutMs);
    addHistory(item, 'online', rt);
    item.lastCheck = now();
    item.failCount = 0;

    // Enhanced SSL check
    const lastSSLCheck = item.lastSSLCheck || 0;
    const sslCheckDue = now() - lastSSLCheck > settings.sslCheckInterval * DAY_MS;

    if (sslCheckDue) {
      const sslResult = await advancedSSLCheck(item.url);
      item.sslInfo = sslResult;
      item.lastSSLCheck = now();

      if (sslResult.daysRemaining <= settings.sslWarningDays) {
        addAlert(item.url, 'SSL Expiry Warning',
          `SSL certificate for ${item.url} expires in ${sslResult.daysRemaining} days (${sslResult.expiryDate})`,
          'warning');
      }
    }

    // Security vulnerability scan (weekly)
    const lastSecurityScan = item.lastSecurityScan || 0;
    if (now() - lastSecurityScan > 7 * DAY_MS) {
      const vulnerabilities = await scanSecurityVulnerabilities(item.url);
      if (vulnerabilities.length > 0) {
        addAlert(item.url, 'Security Vulnerabilities Found',
          `Found ${vulnerabilities.length} potential security issues`, 'warning');
      }
      item.lastSecurityScan = now();
    }

    // Business impact assessment
    const impact = calculateBusinessImpact(item);
    item.businessImpact = impact;

    // Performance budget check
    if (rt > settings.responseTimeCritical) {
      addAlert(item.url, 'Performance Budget Exceeded',
        `Response time ${Math.round(rt)}ms exceeds critical threshold`, 'warning');
    }

  } catch (error) {
    addHistory(item, 'offline', null);
    item.failCount = (item.failCount || 0) + 1;
    
    // Enhanced retry logic with exponential backoff
    if (retryCount < settings.retryFailed) {
      const backoffDelay = Math.pow(2, retryCount) * 2000;
      console.log(`Retrying ${item.url} in ${backoffDelay}ms (${retryCount + 1}/${settings.retryFailed})`);
      setTimeout(() => enhancedCheckUrl(item, retryCount + 1), backoffDelay);
      return;
    }
    
    // Automated incident response for critical URLs
    if (item.businessImpact?.category === 'critical') {
      automatedIncidentResponse(item.url);
    }
    
    addAlert(item.url, 'Connection Error', `Failed to connect to ${item.url}: ${error.message}`, 'error');
    console.warn(`Check failed for ${item.url}:`, error.message);
  }
}

// Update the main checking loop to include new features
function enhancedStartChecking() {
  stopChecking();
  if (settings.intervalSec > 0) {
    checkAll();
    timer = setInterval(() => {
      checkAll();
      
      // Run additional monitoring tasks
      detectAnomalies();
      correlateAlerts();
      checkPerformanceBudgets();
      updateCustomIntervals();
      
      // Resource monitoring
      const resources = monitorResourceUtilization();
      if (resources && resources.utilization > 90) {
        console.warn('High memory utilization:', resources);
      }
      
    }, settings.intervalSec * 1000);
  }
}

// Add new UI components for enhanced features
function renderEnhancedDashboard() {
  // Add AI insights panel
  const insights = calculateAdvancedMetrics();
  const forecasts = forecastMetrics();
  const capacityInsights = generateCapacityInsights();
  
  // This would be called from the existing render function
  // to update the UI with new data
}

// Initialize enhanced features
function initializeEnhancedFeatures() {
  // Build dependency map
  buildDependencyMap();
  
  // Set up data retention policy
  applyDataRetentionPolicy();
  
  // Initialize collaboration features
  collaboration.addUser('System', 'admin');
  
  // Generate initial documentation
  const docs = generateMonitoringDocumentation();
  console.log('Initial documentation:', docs);
  
  // Start enhanced monitoring
  enhancedStartChecking();
}

// Update the existing initializeApp function
function initializeApp() {
  // Existing initialization code...
  
  // Load enhanced settings
  settings = { 
    ...DEFAULT_SETTINGS, 
    ...loadFromStorage('ump_settings', {}),
    // Enhanced default settings
    dataRetentionDays: 30,
    enableAnomalyDetection: true,
    enableForecasting: true,
    enableSecurityScan: true
  };
  
  // Existing initialization continues...
  
  // Initialize enhanced features
  initializeEnhancedFeatures();
}

// Add new settings to the settings modal
function showEnhancedSettings() {
  // Add new settings fields to the modal
  const enhancedSettingsHTML = `
    <div class="rowx" style="grid-template-columns: 170px 1fr;">
      <label>Data Retention (days)</label>
      <input id="dataRetentionDays" type="number" min="1" max="365" value="${settings.dataRetentionDays || 30}" />
    </div>
    <div class="rowx" style="grid-template-columns: 170px 1fr;">
      <label>Enable Anomaly Detection</label>
      <input id="enableAnomalyDetection" type="checkbox" ${settings.enableAnomalyDetection ? 'checked' : ''} />
    </div>
    <div class="rowx" style="grid-template-columns: 170px 1fr;">
      <label>Enable Forecasting</label>
      <input id="enableForecasting" type="checkbox" ${settings.enableForecasting ? 'checked' : ''} />
    </div>
    <div class="rowx" style="grid-template-columns: 170px 1fr;">
      <label>Enable Security Scan</label>
      <input id="enableSecurityScan" type="checkbox" ${settings.enableSecurityScan ? 'checked' : ''} />
    </div>
  `;
  
  // Inject into settings modal
  const settingsBody = document.querySelector('#settingsModal .body');
  settingsBody.innerHTML += enhancedSettingsHTML;
  
  // Show the modal
  elements.modals.settings.style.display = 'flex';
}

// Update saveSettings to include new settings
function saveEnhancedSettings() {
  // Existing settings saving...
  
  // Enhanced settings
  settings.dataRetentionDays = parseInt(document.getElementById('dataRetentionDays').value) || 30;
  settings.enableAnomalyDetection = document.getElementById('enableAnomalyDetection').checked;
  settings.enableForecasting = document.getElementById('enableForecasting').checked;
  settings.enableSecurityScan = document.getElementById('enableSecurityScan').checked;
  
  persistSettings();
  elements.modals.settings.style.display = 'none';
  
  // Re-apply data retention policy
  applyDataRetentionPolicy();
}
</script>
